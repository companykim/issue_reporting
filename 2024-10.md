# 2024.10.22

## sync와 async의 차이

둘의 차이점은 작업이 수행되는 방식과 결과가 반환되는 시점에서 나타난다.

동기(synchronous): 작업이 실행될 때, 해당 작업이 완료될 때까지 기다린다. 즉, 해당 작업이 끝나기 전까지는 다른 작업을 수행하지 않는다. 이 작업이 완료된 후에는 결과가 반환된다. </br>
비동기(asynchronous): 작업이 실행되고 완료되는 동안 다른 작업을 수행할 수 있다. 즉, 해당 작업이 완료되지 않았더라고도 다른 작업을 수행할 수 있다. 결과는 작업이 완료될 때 반환된다. </br>

위의 차이는 다중 스레드 또는 이벤트 기반 프로그래밍에서 중요해지는데, </br>
동기 방식에서는 작업이 완료될 때까지 다른 작업을 수행하지 않기 때문에 다른 작업에 차단될 수 있다. </br>
하지만 비동기 방식에서는 작업이 완료될 때까지 다른 작업을 수행하고 결과가 반환되면 해당 작업에 대한 콜백(callback)함수를 호출하여 결과를 처리한다. 

## 
예를 들어, 클라이언트에서 이름, 나이, 출석 여부를 입력받아서 서버에서 처리를 해야한다고 가정을 하자. </br>
위 입력값을 입력하여 서버에 처리를 요청했을시에 서버에서는 입력값을 처리한 결과를 gm이라고 하는 응답 메세지와 처리 여부(mt)로 클라이언트에 전송한다. </br>
이렇게 되면 만일 여러 건을 동시에 처리할 때에는 어떤 건이 처리가 되었는지를 알 수 없다. 그렇기 때문에 입력한 값들이 건마다 제대로 처리가 되었는지에 대해 명확하게 표기해주어 클라이언트에 처리 결과를 전송해주어야 한다.

# 2024.10.23

##
관리 TR의 경우 오류 메시지나 성공여부가 헤더에 저장된다.

## 사회생활
제발 검토나 질문 좀 제대로 하자. 나 혼자 너무 앞서가지 말자. 할거면 제대로 하자.

# 2024.10.30

## GetCodeNm

GetCodeNm('KOR',ITEM,VAL)만 SELECT 구문에 넣어서 조회하면 에러가 발생한다. 이유는 GetCodeNm 함수에서 반환하는 문자열 길이가 VAL 열의 데이터 타입 길이 제한을 초과했기 때문이다. </br>
GetCodeNm('KOR',ITEM,VAL)을 단순히 AS VAL로 사용했을 때는, VAL 열의 데이터 타입 제한을 고려하지 않고 GetCodeNm의 반환 값을 그대로 저장하려고 시도한다. </br>
이로 인해 특정 레코드의 반환 값이 길이 제한을 초과하면 Data truncation : Data too long for column 'p_code' at row 8 오류가 발생한다.

반면, IF(SECT = 'C', GetCodeNm('KOR',ITEM,VAL),VAL)과 같은 조건문을 사용하면 SECT가 C인 경우에만 GetCodeNm 함수를 사용하고 그렇지 않으면 기존의 VAL 값을 그대로 사용하므로 길이 초과 문제를 피할 수 있다.
